# Object-Oriented Programming (OOP) in Python
This folder contains a series of Python files designed to help you understand the fundamental concepts of Object-Oriented Programming (OOP). Each file focuses on a single, key principle, providing a clear code example and detailed explanations.

## Core OOP Concepts
Here is a breakdown of the topics covered in this collection of files:

### 📝 Classes and Objects
File: classes_and_objects.py

Summary: This file introduces the foundational concepts of classes as blueprints and objects as instances of those classes. It demonstrates how to define a class and create an object from it.

### 🏗️ The __init__ Method
File: init_method.py

Summary: Learn about the __init__() method, which serves as the constructor in Python. This file shows how this special method automatically initializes an object's attributes upon creation.

### 🔗 The self Parameter
File: self_parameter.py

### Summary: 
This file explains the role of the self parameter, which is a reference to the current instance of the class. It is essential for accessing an object's attributes and methods from within the class.

### 🗣️ The __str__ Method
File: str_method.py

### Summary: 
This example demonstrates how to use the __str__() method to create a custom, human-readable string representation for your objects, improving their readability when printed.

### 📚 Class vs. Instance Variables
File: class_and_instance_variables.py

### Summary: 
This file highlights the crucial distinction between class variables (shared across all instances) and instance variables (unique to each object), showing how to access and modify each type.

## Advanced OOP Concepts

### 🛡️ Getter and Setter Methods
File: getter_setter_methods.py

### Summary: 
Explore the concept of encapsulation through getter and setter methods. This file shows how to use @property decorators to provide controlled access to an object's attributes.

### 🔄 Method Overriding
File: method_overriding.py

### Summary: 
This example illustrates method overriding, a form of polymorphism where a subclass provides its own specific implementation of a method that is already defined in its superclass.

### ⚙️ Static and Class Methods
File: static_and_class_methods.py

### Summary: 
Understand the difference between static methods (not bound to an instance or class) and class methods (bound to the class itself), and when to use each.

### 🧱 Abstract Classes and Methods
File: abstract_classes.py

### Summary:
Learn about abstract classes, which act as a blueprint for other classes and cannot be instantiated directly. This file shows how to define abstract methods that must be implemented by subclasses.

This README.md provides a quick reference to the files and the concepts they cover. You can navigate to each file to see the detailed code and comments.